# 유니버스(Universe)

## 플로팅 오리진 시스템이란?

일반적인 유니티 씬은 3개의 부동 소수점(Vector3)을 사용하여 위치를 저장합니다. 여기서 0,0,0의 위치를 씬의 원점이라고 합니다. 이 시스템은 좁은 지역에서 진행되는 대부분의 게임에 적합하지만 우주를 배경으로 하는 게임은 종종 수천 혹은 수백만 킬로미터 이상을 이동해야 하므로 Vector3만으로는 일관되게 동작할 수 없습니다.

문제는 float 값이 커질수록 소수점 정밀도가 손실된다는 것입니다. 즉, 우주선이 씬의 중심에서 100만 미터/유닛(유니티 단위) 이상 떨어졌을 때, 카메라 및 위치 값의 정확도가 매우 떨어지고 이로 인해서 그래픽 및 물리 등에서 문제를 발생시킵니다. 따라서 플로팅 오리진 시스템에서는 위치 값을 가능한 한 원점(0, 0, 0)에 가깝게 유지하여 부동 소수점 정확도를 높게 유지하려고 합니다.

많은 해결책 중에 한 가지는 카메라를 이동하는 대신에 원점(0, 0, 0)에 고정시키고 씬의 모든 객체를 카메라가 정상적으로 이동했을 거리만큼 이동하는 것입니다. 이 방식은 잘 동작하겠지만 움직이는 객체는 특정한 경우에 계산 비용이 많이 들기 때문에(예:움직이는 물리 객체) 성능 문제가 발생할 수 있습니다. 그 뿐만 아니라 이런 방식은 씬 설정을 더 어렵게 만들 수 있으며 카메라가 움직일 수 있을 것으로 예상하는 기존 컴포넌트 및 스크립트에 문제가 발생할 수 있습니다.

SGT가 사용하는 더 나은 솔루션은 카메라를 항상 원점으로 유지하는 대신, 카메라가 너무 멀리 이동할 때, 다시 원점으로 스냅하는 것입니다. 이 접근 방식은 객체가 가끔씩만 위치를 이동하도록 만들어주기 때문에 좋은 성능을 제공하고 값이 항상 원점 근처에 있게 해주기 때문에 좋은 렌더링 정밀도를 유지합니다.

## 주의!

이 플로팅 오리진 시스템을 사용법을 확인하기 전에 기존에 개발된 프로젝트에 포함하도록 업데이트하는 것이 어렵다는 점을 명심하십시오. 원인이 무엇인지 명확하지 않은 상태에서 많은 기능이 정상적으로 동작하지 않을 수 있기 때문입니다. 새 프로젝트에만 이 기능을 포함하는 것이 좋습니다. 여기서 항목을 하나씩 추가하여 씬이 중단되는 원인이 된 변경 사항을 즉시 알 수 있습니다.

또한 월드 공간 위치를 저장하는 것은 플로팅 오리진 시스템에서 좋은 생각이 아님을 명심하십시오. 이러한 위치는 영구적이지 않기 때문입니다. 예를 들어 특정 Vector3 월드 공간 위치를 추적하는 미사일 스크립트가 있는 경우 카메라가 스냅되는 즉시 잘못된 위치를 추적하기 시작합니다. 이 값을 업데이트하려면 **SgtFloatingCamera.OnSnap**에 연결하고, 대신 상대 월드 공간 위치를 저장하거나 **Transform** 컴포넌트를 사용할 수도 있습니다.

마지막으로, 여러 대의 분리된 카메라(예:분할 화면, 보안 카메라)로 게임을 만드는 경우, 모든 카메라는 항상 서로 적당한 거리 내에 있어야 합니다. 이 플로팅 오리진 시스템은 한 명의 관찰자를 염두에 두고 설계되었기 때문에, 따라서 원점 자체는 한 번에 하나의 메인 카메라만 이동할 수 있습니다. 이것은 두 플레이어가 우주 반대편에 있는 분할 화면 게임을 가질 수 없다는 것을 의미합니다. 그 이유는 씬 설정을 처리하기가 너무 복잡하기 때문입니다.

## 기본 설정

가장 기본적인 수준에서 **SgtFloatingCamera** 컴포넌트를 게임 오브젝트(예:Main Camera)에 추가하고 **SgtFloatingObject** 컴포넌트를 다른 모든 게임 오브젝트(예:우주선, 행성, 캐릭터, 적, 소행성)에 추가하기만 하면 됩니다.

완료되면 카메라가 원점에서 100유닛(기본값) 이상 멀어지면 위치가 원점으로 다시 스냅되고 장면의 모든 객체가 같은 값만큼 이동하는 것을 볼 수 있습니다.

> **NOTE** - **SgtFloatingObject** 및 **SgtFloatingCamera** 컴포넌트(예:부모 및 자식 오브젝트)를 중첩해서 사용할 수 없습니다. 한 오브젝트가 다른 오브젝트를 따르도록 하려면 둘을 분리하고 **SgtFloatingFollow** 컴포넌트를 사용하여 다시 연결해야 합니다. 기술적으로 이를 지원하는 것을 가능하지만 코드를 훨씬 더 복잡하게 만들고 성능을 저하시킵니다.

## 스냅 다루기

카메라가 스냅될 때마다 스크립트를 업데이트해야 하는 경우 **SgtFloatingCamera**.OnSnap 이벤트에 연결할 수 있습니다. 이 이벤트는 **SgtFloatingCamera**에 대한 참조를 제공하고 씬이 이동한 월드 공간 거리를 포함하는 **Vector3**를 제공합니다.

스크립트가 월드 공간 위치를 저장하는 경우 이 이벤트에 연결하고 이벤트가 제공하는 이 월드 공간 델타만큼 값을 증가시켜야 합니다.

## 고정밀 위치(High Precision Positions)

**SgtFloatingCamera** 및 **SgtFloatingObject** 컴포넌트를 분석해보셨다면 이 두 컴포넌트 모두 **Local X/Y/Z** 및 **Global X/Y/Z** 값을 저장한다는 것을 눈치채셨을 겁니다. 이러한 값을 **SgtPosiotn**이라고 하며 이를 통해 오브젝트를 우주 어디에서나 높은 정확도로 배치할 수 있습니다.

Local 값은 단일 월드 공간 단위(미터)에 해당하고 Global 값은 각각 50,000,000단위(미터)에 해당합니다. Local 값이 +/-50,000,000 값을 초과할 때마자 0으로 재설정되고 Global 값이 증가하거나 감속합니다.

이 값을 결합하여 한계까지 사용하면 각 축에서 +/-461,168,601,842,738,790,400,000,000미터의 오브젝트 위치를 정확하게 저장할 수 있습니다. 이것은 +/-48,745,559,677광년 또는 487억 광년에 해당하며 관측 가능한 우주의 466억 광년 반경보다 큽니다.

## 계층적 생성

우주는 거대하고 우주의 모든 물체를 동시에 활성화하는 것은 비현실적입니다(예: 은하, 별, 행성, 달). 왜냐하면 이 모든 것을 렌더링하려고 했다가는 컴퓨터가 폭발할 것이기 때문입니다. 그러나 올바른 방식으로 디자인하면 완전한 우주를 만들 수 있습니다.

이 방법의 핵심은 계층 구조로 모든 것을 생성하는 것입니다. 예를 들어:

1. 몇 개의 은하를 생성합니다.
2. 카메라가 은하에 가까워지면 거대한 성단을 나타내는 빌보드 스프라이트를 내부에 생성합니다.
3. 카메라가 이 클러스터 중 하나에 가까워지면 거대한 클러스터 내부에 작은 클러스터를 생성합니다.
4. 카메라가 이 작은 클러스터 중 하나에 가까워지면 이 안에 더 작은 클러스터를 생성합니다.
5. 카메라가 이 더 작은 클러스터에 가까워지면 이제 실제 3D 항성을 생성할 수 있습니다.
6. 카메라가 이 항성 중 하나에 더 가까워지면 주변에 행성을 생성합니다.
7. 카메라가 이 행성 중 하나에 가까워지면 몇 개의 위성을 생성합니다

이런 식으로 잘 디자인하면 씬에 동시에 활성화된 오브젝트가 수백개를 넘지 않지만, 여전히 수백만 개의 별과 행성이 있는 것처럼 보일 것입니다.

이 모든 것은 **SgtSpawner__** 컴포넌트를 사용하여 구성할 수 있으며, 카메라가 지정한 **Range** 내에 있을 때 특정 분포에서 프리팹을 생성할 수 있습니다.

## 거대한 물체(Massive Objects)

위에서 설명한 기본 설정은 거대한 장면에서 ‘작은’ 물체(예: 우주선, 행성, 별)을 대상으로는 잘 작동하지만 은하와 같은 정말로 거대한 천체를 렌더링할 수는 없습니다. 이는 유니티가 구현되는 방식의 한계로 인해 특정한 크기/거리 이상의 오브젝트는 그냥 사라지게 됩니다.

그러나 Space Graphics Toolkit은 이 문제를 해결할 수 있는 **SgtFloatingMassive** 컴포넌트와 함께 제공됩니다. 이 컴포넌트는 현재 게임 오브젝트의 **Transform** 설정을 가져와서 거대한 개체의 크리를 조정하고 위치를 지정하야 마치 거대하고 멀리 있는 것처럼 보이게 만들어 줍니다. 하지만 실제로는 작고 상당히 가깝습니다.

씬이 은하 및 기타 거대하고 멀리 있는 물체를 렌더링할 수 있어야 하는 경우 **SgtFloatingObject** 컴포넌트 대신 **SgtFloatingMassive** 컴포넌트를 연결해야 합니다.

> **NOTE** - 이 컴포넌트는 **Rigidbody** 컴포넌트 또는 **Transform** 설정을 수동으로 설정하는 다른 컴포넌트와 함께 사용할 수 없습니다.

> **NOTE** - 이 컴포넌트는 **SgtFloatingObject**보다 더 많은 오버헤드를 가지므로 이 기능은 **SgtFloatingObject**로 제대로 렌더링할 수 없는 장면의 정말 거대한 개체에만 사용해야 합니다.

> **NOTE** - 이 컴포넌트는 **Transform** 설정을 가져와서 카메라를 기준으로 위치를 지정하므로 이 위치를 기반으로 게임 내 로직을 수행할 수 없습니다. 거대한 개체의 실제 위치를 찾아야 하는 경우 **SgtFloatingMassive** 컴포넌트에서 해당 **Position** 데이터를 읽어야 합니다.